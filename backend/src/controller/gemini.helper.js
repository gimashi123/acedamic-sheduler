/**
 * Gemini AI Helper Functions for Timetable Generation
 * This file contains helper functions for working with the Gemini API
 */

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

/**
 * The Gemini API endpoint for text generation
 */
const GEMINI_API_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent';

/**
 * Check if the Gemini API key is configured
 * @returns {boolean} True if the API key is configured
 */
export const isGeminiConfigured = () => {
  return !!process.env.GEMINI_API_KEY;
};

/**
 * Generate a timetable using the Gemini API
 * @param {Object} data - The data to send to Gemini
 * @param {Object} data.group - The group information
 * @param {Array} data.subjects - The subjects information
 * @param {Array} data.venues - The venues information
 * @param {Array} data.timeSlots - The available time slots
 * @param {Array} data.days - The available days
 * @param {Object|null} data.previousTimetable - The previous timetable to improve (if any)
 * @returns {Promise<Array>} The timetable slots generated by Gemini
 */
export const generateTimetableWithGemini = async (data) => {
  if (!isGeminiConfigured()) {
    throw new Error('Gemini API key is not configured');
  }

  try {
    // Construct the prompt text
    const promptText = constructPrompt(data);
    
    // Send the request to Gemini API
    const response = await axios.post(
      `${GEMINI_API_ENDPOINT}?key=${process.env.GEMINI_API_KEY}`,
      {
        contents: [{
          parts: [{
            text: promptText
          }]
        }]
      }
    );
    
    // Extract the timetable slots from the response
    return parseGeminiResponse(response.data);
  } catch (error) {
    console.error('Error calling Gemini API:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Construct the prompt text for Gemini
 * @param {Object} data - The data to include in the prompt
 * @returns {string} The prompt text
 */
const constructPrompt = (data) => {
  return `Generate an optimal academic timetable for the following data. 
  Take into account constraints like no lecturer teaching multiple classes at once, 
  no group having multiple classes at once, and no venue hosting multiple events at once.
  Optimize for minimal gaps in the student schedule. Each subject should be allocated
  for a 2-hour slot.
  
  Previous timetable to improve (if available): ${JSON.stringify(data.previousTimetable)}
  
  Group: ${JSON.stringify(data.group)}
  Available subjects: ${JSON.stringify(data.subjects)}
  Available venues: ${JSON.stringify(data.venues)}
  Available time slots: ${JSON.stringify(data.timeSlots)}
  Available days: ${JSON.stringify(data.days)}
  
  Respond with a JSON array of timetable slots, each containing: day, startTime, endTime, subjectId, venueId, lecturerId.
  Ensure there are no conflicts for venues, lecturers, or the student group.`;
};

/**
 * Parse the response from Gemini API
 * @param {Object} response - The response from Gemini API
 * @returns {Array} The parsed timetable slots
 */
export const parseGeminiResponse = (response) => {
  try {
    // Extract text from the response
    const text = response.candidates[0].content.parts[0].text;
    
    // Find JSON array in the text
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    
    if (jsonMatch) {
      const slots = JSON.parse(jsonMatch[0]);
      return slots.map(slot => ({
        day: slot.day,
        startTime: slot.startTime,
        endTime: slot.endTime,
        subject: slot.subjectId,
        venue: slot.venueId,
        lecturer: slot.lecturerId
      }));
    } else {
      console.warn('Could not extract JSON from Gemini API response');
      return [];
    }
  } catch (error) {
    console.error('Error parsing Gemini API response:', error);
    return [];
  }
};

export default {
  isGeminiConfigured,
  generateTimetableWithGemini,
  parseGeminiResponse
}; 